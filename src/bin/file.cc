/*
 * Copyright (c) 2013-2015 Martin Donath <martin.donath@squidfunk.com>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to
 * deal in the Software without restriction, including without limitation the
 * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
 * sell copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 */

#include <ctime>
#include <map>
#include <string>

#include <google/protobuf/descriptor.h>
#include <google/protobuf/io/printer.h>
#include <google/protobuf/stubs/common.h>

#include "bin/file.hh"
#include "bin/message.hh"
#include "bin/strutil.hh"

/* ----------------------------------------------------------------------------
 * Interface
 * ------------------------------------------------------------------------- */

namespace protobluff {

  using ::std::map;
  using ::std::string;

  using ::google::protobuf::FileDescriptor;
  using ::google::protobuf::io::Printer;
  using ::google::protobuf::scoped_array;
  using ::google::protobuf::scoped_ptr;

  using ::google::protobuf::StripSuffixString;
  using ::google::protobuf::StringReplace;
  using ::google::protobuf::UpperString;

  /*!
   * Create a file generator.
   *
   * \param[in] descriptor File descriptor
   */
  File::
  File(const FileDescriptor *descriptor) :
      descriptor(descriptor),
      messages(new scoped_ptr<Message>[descriptor->message_type_count()]) {

    /* Initialize messages */
    for (size_t m = 0; m < descriptor->message_type_count(); m++)
      messages[m].reset(new Message(descriptor->message_type(m)));

    /* Generate datetime string */
    time_t   unixtime = time(0);
    strftime(datetime, sizeof(datetime),
      "%x %X", localtime(&unixtime));
  }

  /*!
   * Generate header file.
   *
   * \param[in,out] printer Printer
   */
  void File::
  GenerateHeader(Printer *printer) const {
    map<string, string> variables;

    /* Extract description information */
    variables["datetime"] = datetime;
    variables["filename"] = descriptor->name();
    variables["package"]  = descriptor->package().size() > 0
      ? descriptor->package() : "-";

    /* Generate description and disclaimer */
    printer->Print(variables,
      "/*\n"
      " * Generated by the Protobluff compiler - do not edit.\n"
      " * ----------------------------------------------------------------------------\n"
      " * Date:     `datetime`\n"
      " * Filename: `filename`\n"
      " * Package:  `package`\n"
      " * ----------------------------------------------------------------------------\n"
      " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
      " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
      " * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n"
      " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
      " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n"
      " * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n"
      " * IN THE SOFTWARE.\n"
      " */\n"
      "\n");

    /* Extract and prepare guard name */
    variables["guard"] = StringReplace(
      StripSuffixString(descriptor->name(), ".proto"),
    ".", "_", true);
    UpperString(&(variables["guard"]));

    /* Generate guard header and library includes */
    printer->Print(variables,
      "#ifndef `guard`_PB_H\n"
      "#define `guard`_PB_H\n"
      "\n"
      "#include <protobluff.h>\n"
      "\n");

    /* Generate dependent includes */
    if (descriptor->dependency_count()) {
      bool includes = false;
      for (size_t d = 0; d < descriptor->dependency_count(); d++) {
        string dependency = descriptor->dependency(d)->name();
        printer->Print("#include \"`dependency`.pb.h\"\n", "dependency",
          StripSuffixString(dependency, ".proto"));
        includes = true;
      }
      if (includes)
        printer->Print("\n");
    }

    /* Generate forward declaration header */
    printer->Print(
      "/* ----------------------------------------------------------------------------\n"
      " * Forward declarations\n"
      " * ------------------------------------------------------------------------- */\n"
      "\n");

    /* Generate forward declarations */
    for (size_t m = 0; m < descriptor->message_type_count(); m++)
      messages[m]->GenerateDeclarations(printer);

    /* Generate accessor header */
    printer->Print(
      "/* ----------------------------------------------------------------------------\n"
      " * Assertions\n"
      " * ------------------------------------------------------------------------- */\n"
      "\n");

    /* Generate descriptor assertions */
    for (size_t m = 0; m < descriptor->message_type_count(); m++)
      messages[m]->GenerateDescriptorAssertions(printer);

    /* Print separator */
    printer->Print(
      "/* ----------------------------------------------------------------------------\n"
      " * Definitions\n"
      " * ------------------------------------------------------------------------- */\n"
      "\n");

    /* Generate definitions */
    for (size_t m = 0; m < descriptor->message_type_count(); m++)
      messages[m]->GenerateDefinitions(printer);

    /* Generate guard footer */
    printer->Print(variables,
      "#endif /* `guard`_PB_H */");
  }

  /*!
   * Generate source file.
   *
   * \param[in,out] printer Printer
   */
  void File::
  GenerateSource(Printer *printer) const {
    map<string, string> variables;

    /* Extract description information */
    variables["datetime"] = datetime;
    variables["filename"] = descriptor->name();
    variables["package"]  = descriptor->package().size() > 0
      ? descriptor->package()
      : "-";

    /* Generate description and disclaimer */
    printer->Print(variables,
      "/*\n"
      " * Generated by the Protobluff compiler - do not edit.\n"
      " * ----------------------------------------------------------------------------\n"
      " * Date:     `datetime`\n"
      " * Filename: `filename`\n"
      " * Package:  `package`\n"
      " * ----------------------------------------------------------------------------\n"
      " * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n"
      " * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n"
      " * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. IN NO EVENT SHALL THE\n"
      " * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n"
      " * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n"
      " * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n"
      " * IN THE SOFTWARE.\n"
      " */\n"
      "\n");

    /* Generate library includes */
    printer->Print(variables,
      "#include <protobluff/descriptor.h>\n"
      "\n");

    /* Generate header include */
    variables["include"] = StripSuffixString(descriptor->name(), ".proto");
    printer->Print(variables,
      "#include \"`include`.pb.h\"\n"
      "\n");

    /* Generate default header */
    for (size_t m = 0; m < descriptor->message_type_count(); m++)
      if (messages[m]->HasDefaults()) {
        printer->Print(
          "/* ----------------------------------------------------------------------------\n"
          " * Defaults\n"
          " * ------------------------------------------------------------------------- */\n"
          "\n");
        break;
      }

    /* Generate defaults */
    for (size_t m = 0; m < descriptor->message_type_count(); m++)
      messages[m]->GenerateDefaults(printer);

    /* Generate descriptor header */
    printer->Print(
      "/* ----------------------------------------------------------------------------\n"
      " * Descriptors\n"
      " * ------------------------------------------------------------------------- */\n"
      "\n");

    /* Generate descriptors */
    for (size_t m = 0; m < descriptor->message_type_count(); m++)
      messages[m]->GenerateDescriptors(printer);
  }
}